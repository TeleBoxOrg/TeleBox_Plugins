name: Update README Plugin List

on:
  push:
    branches: [ main ]
    paths: [ 'plugins.json' ]
  pull_request:
    branches: [ main ]
    paths: [ 'plugins.json' ]
  workflow_dispatch:

jobs:
  update-readme:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Update README plugin list via GitHub API
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_REF: ${{ github.ref }}
      run: |
        node -e "
        const https = require('https');
        const fs = require('fs');
        
        // GitHub API é…ç½®
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
        const branch = process.env.GITHUB_REF.replace('refs/heads/', '');
        
        // å…¬å…± API è¯·æ±‚å‡½æ•°
        function apiRequest(path, method = 'GET', data = null) {
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.github.com',
              path: path,
              method: method,
              headers: {
                'User-Agent': 'TeleBox-Plugin-Updater',
                'Accept': 'application/vnd.github.v3+json'
              }
            };
            
            if (data) {
              options.headers['Content-Type'] = 'application/json';
            }
            
            const req = https.request(options, (res) => {
              let body = '';
              res.on('data', chunk => body += chunk);
              res.on('end', () => {
                try {
                  const result = JSON.parse(body);
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    resolve(result);
                  } else {
                    reject(new Error(\`API Error: \${res.statusCode} - \${result.message}\`));
                  }
                } catch (e) {
                  reject(new Error(\`Parse Error: \${e.message}\`));
                }
              });
            });
            
            req.on('error', reject);
            
            if (data) {
              req.write(JSON.stringify(data));
            }
            
            req.end();
          });
        }
        
        async function main() {
          try {
            // è·å–å½“å‰ plugins.json å†…å®¹
            const pluginsResponse = await apiRequest(\`/repos/\${owner}/\${repo}/contents/plugins.json?ref=\${branch}\`);
            const pluginsContent = Buffer.from(pluginsResponse.content, 'base64').toString('utf8');
            const pluginsData = JSON.parse(pluginsContent);
            
            // è·å–å½“å‰ README.md å†…å®¹
            const readmeResponse = await apiRequest(\`/repos/\${owner}/\${repo}/contents/README.md?ref=\${branch}\`);
            const readmeContent = Buffer.from(readmeResponse.content, 'base64').toString('utf8');
            
            // æå–æ’ä»¶ä¿¡æ¯å¹¶æ’åºå»é‡
            const plugins = Object.keys(pluginsData)
              .map(name => ({
                name: name.trim(),
                desc: pluginsData[name].desc.trim()
              }))
              .filter((plugin, index, self) => 
                index === self.findIndex(p => p.name === plugin.name)
              )
              .sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
            
            // ç”Ÿæˆæ’ä»¶åˆ—è¡¨ markdown (ä¿æŒåŸæ ¼å¼ï¼Œæ¯è¡Œæœ«å°¾æ·»åŠ ä¸¤ä¸ªç©ºæ ¼)
            const pluginListMd = plugins
              .map(plugin => \`- \\\`\${plugin.name}\\\` - \${plugin.desc}  \`)
              .join('\\n');
            
            // å®šä¹‰æ›¿æ¢çš„å¼€å§‹å’Œç»“æŸæ ‡è®°
            const startMarker = '## å¯ç”¨æ’ä»¶åˆ—è¡¨';
            const endMarker = '## æŠ€æœ¯æ ˆ';
            
            // æŸ¥æ‰¾æ ‡è®°ä½ç½®
            const startIndex = readmeContent.indexOf(startMarker);
            const endIndex = readmeContent.indexOf(endMarker);
            
            if (startIndex === -1 || endIndex === -1) {
              console.error('æœªæ‰¾åˆ°æ’ä»¶åˆ—è¡¨æ ‡è®°');
              process.exit(1);
            }
            
            // æ„å»ºæ–°çš„ README å†…å®¹
            const beforeSection = readmeContent.substring(0, startIndex + startMarker.length);
            const afterSection = readmeContent.substring(endIndex);
            
            const newReadmeContent = \`\${beforeSection}\\n\${pluginListMd}\\n\\n\${afterSection}\`;
            
            // æ£€æŸ¥å†…å®¹æ˜¯å¦æœ‰å˜åŒ–
            if (readmeContent === newReadmeContent) {
              console.log('âœ… README.md å·²æ˜¯æœ€æ–°çŠ¶æ€ï¼Œæ— éœ€æ›´æ–°');
              return;
            }
            
            // åˆ›å»º Pull Request è€Œä¸æ˜¯ç›´æ¥æäº¤
            const prTitle = 'ğŸ¤– è‡ªåŠ¨æ›´æ–°æ’ä»¶åˆ—è¡¨';
            const prBody = \`## è‡ªåŠ¨æ›´æ–°æ’ä»¶åˆ—è¡¨\\n\\n- ä» plugins.json åŒæ­¥æ’ä»¶ä¿¡æ¯\\n- æŒ‰å­—æ¯é¡ºåºæ’åº\\n- è‡ªåŠ¨å»é‡å¤„ç†\\n\\n**æ’ä»¶æ•°é‡**: \${plugins.length}\\n**æ’ä»¶åˆ—è¡¨**: \${plugins.map(p => p.name).join(', ')}\\n\\n---\\n*æ­¤ PR ç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ*\`;
            
            // åˆ›å»ºæ–°åˆ†æ”¯
            const branchName = \`auto-update-plugins-\${Date.now()}\`;
            
            // è·å–ä¸»åˆ†æ”¯çš„æœ€æ–° commit SHA
            const mainBranchResponse = await apiRequest(\`/repos/\${owner}/\${repo}/git/refs/heads/\${branch}\`);
            const baseSha = mainBranchResponse.object.sha;
            
            // åˆ›å»ºæ–°åˆ†æ”¯å¼•ç”¨
            await apiRequest(\`/repos/\${owner}/\${repo}/git/refs\`, 'POST', {
              ref: \`refs/heads/\${branchName}\`,
              sha: baseSha
            });
            
            // æ›´æ–° README.md æ–‡ä»¶
            await apiRequest(\`/repos/\${owner}/\${repo}/contents/README.md\`, 'PUT', {
              message: prTitle,
              content: Buffer.from(newReadmeContent).toString('base64'),
              sha: readmeResponse.sha,
              branch: branchName
            });
            
            // åˆ›å»º Pull Request
            const prResponse = await apiRequest(\`/repos/\${owner}/\${repo}/pulls\`, 'POST', {
              title: prTitle,
              head: branchName,
              base: branch,
              body: prBody
            });
            
            // å¯ç”¨è‡ªåŠ¨åˆå¹¶
            try {
              await apiRequest(\`/repos/\${owner}/\${repo}/pulls/\${prResponse.number}/merge\`, 'PUT', {
                commit_title: prTitle,
                commit_message: \`è‡ªåŠ¨æ›´æ–°æ’ä»¶åˆ—è¡¨ (\${plugins.length} ä¸ªæ’ä»¶)\`,
                merge_method: 'squash'
              });
              
              console.log(\`âœ… Pull Request å·²è‡ªåŠ¨åˆå¹¶: \${prResponse.html_url}\`);
              
              // åˆ é™¤ä¸´æ—¶åˆ†æ”¯
              try {
                await apiRequest(\`/repos/\${owner}/\${repo}/git/refs/heads/\${branchName}\`, 'DELETE');
                console.log(\`ğŸ§¹ å·²æ¸…ç†ä¸´æ—¶åˆ†æ”¯: \${branchName}\`);
              } catch (deleteError) {
                console.log(\`âš ï¸ æ¸…ç†åˆ†æ”¯å¤±è´¥: \${deleteError.message}\`);
              }
              
            } catch (mergeError) {
              console.log(\`âš ï¸ è‡ªåŠ¨åˆå¹¶å¤±è´¥ï¼Œéœ€è¦æ‰‹åŠ¨å¤„ç†: \${mergeError.message}\`);
              console.log(\`ğŸ“‹ Pull Request é“¾æ¥: \${prResponse.html_url}\`);
            }
            
            console.log(\`ğŸ“¦ æ›´æ–°äº† \${plugins.length} ä¸ªæ’ä»¶\`);
            
          } catch (error) {
            console.error('âŒ æ›´æ–°å¤±è´¥:', error.message);
            process.exit(1);
          }
        }
        
        main();
        "
